## :dart: Requirements

### :spiral_notepad: Description

I want to write a small program to learn something about blockchain technology. My idea was to save data defining a status of a software deployment in a blockchain. 

> [!NOTE]
> I would not recommend to use this in production but as a learning project it is fine. There are exisiting solutions like [sigstore/rekor: Software Supply Chain Transparency Log](https://github.com/sigstore/rekor) which do similar things. But I want to implement it on my own to learn something about blockchains. 

The data I want to save are:

- Name of the software
- Version number
- Timestamp of deployment
- Commit hash
- Url to repository
- Author like name of company
- Contact information like email
- Merkle root of the deployed files

The name, the version number and the timestamp are metainformation about the deployment. It just improves the readability and helps the user to identify what version of what product he has. With this information the user can check for a downloaded software if the version exists and when it was deployed.

The commit hash and the url to the repository allow to identify the source code of the deployment. By inspecting the commit a signing with GPG might give further trust to the code. For example, it shows that GitHub knows the identity of the author who pushed the code.

> [!IMPORTANT]
> I will develop this project with Git and GitHub in mind. Other version control systems and repository hosting services are out of scope for now but the data model should be designed in a way that it can be extended later.

The author and contact information allow to identify who did the deployment. It is just for transparency. 

The merkle root allows to verify the integrity of the deployed files. It is a hash value calculated from all files of the deployment. By comparing the merkle root stored in the blockchain with a merkle root calculated from the deployed files, it is possible to verify that no file has been changed after the deployment.

This builds a chain of trust from the author who did the deployment and siges the block to the source code and the deployed files. Transparently stored in a blockchain to prevent manipulation. Users can verify the integrity of the deployed files by themselves.

This builds a chain of trust like this:

```mermaid
block
Author<["Author"]>(right)
Commit<["Commit"]>(right)
Repo<["Repository"]>(right)
Build<["Build"]>(right)
Blockchain>"Blockchain"]
```

```mermaid
---
title: "Process of creating a deployment record"
---
flowchart TD
  Start@{ shape: sm-circ, label: "Small start" } --> Author["Author"]
  Author ==>| signs with GPG | Commit["Commit"]
  Commit ==>| pushed to | Repo["Repository"]
  Repo -.-> | verifies | Author
  Repo ==> | triggers | Build["Build"]
  Build ==> | triggers | Deployment["Deployment"]
  Deployment ==> | calculates merkle root | MerkleRoot["Merkle root of deployed files"]
  MerkleRoot ==> | stored in | Blockchain["Blockchain"]
  Blockchain -.-> | verifies with merkle root | Deployment
  Blockchain -.-> | verifies with url and commit hash | Repo
  Blockchain -.-> | verifies with signature | Author
```

The program should allow to add new deployment records to the blockchain and sign them with a key as a developer and to verify existing records by users.

### :question: Open Questions?
1. @Who: What must be discussed?

### :construction: Blockers

1. Something blocks my work.

### :inbox_tray: Input
- Name of the software
- Version number
- Timestamp of deployment
- Commit hash
- Url to repository
- Author like name of company
- Contact information like email

### :outbox_tray: Output

- Merkle root of the deployed files
- A block in the blockchain containing the deployment record.

### :control_knobs: Conditions

None

### :warning: Side effects

Are there any?

## :heavy_check_mark: Acceptance tests

- [ ] I will check that all needed data is stored in the blockchain.
- [ ] I will check the chain of trust by checking the signature of the author in GitHub. Than in the blockchain the project url and commit hash. Finally the merkle root of the deployed files. Lastly I will check the signature of the deployment record with the public key of the developer.

## :triangular_ruler: Design

I will write a cli app in Python because it is also a Python workshop. The app should be able to automate all steps developers or users have to do. Those are adding a new deployment record to a blockchain. The new block should be broadcasted to other nodes in the network. Users should be able to verify existing deployment records by checking the signatures and the merkle root.

The app needs to have functions to create a merkle root from a set of files. A deployment is always a set of files. It might be a set of binaries or an installer or just source code. The deployment must be organized in a folder. This folder is the input for the merkle root calculation. The directory is scanned for files and all files are listed as the method `.rglob("*")` from `pathlib` returns them. `.gitignore` files are honored. The folder `.git` and exactly those files ignored by git are not considered for the merkle root calculation. The files are hashed with SHA256. The hashes are combined pairwise and hashed again until only one hash remains. This is the merkle root.

```mermaid
---
title: "Calculating the merkle root"
---
flowchart TD
    Start@{ shape: sm-circ, label: "Small start" } --> Folder[/"Folder with files"/]
    Folder --> GetFile["Get file in folder"]
    subgraph listFiles["List files"]
    GetFile --> IsIgnored{Ignore?}
    IsIgnored -- Yes --> GetFile
    IsIgnored -- No --> AddFileToList["Add file to list"]
    end
    listFiles --> FilesToHash("Files to hash")
    FilesToHash --> HashFile["Hash file with SHA256"]
    HashFile --> Hashes("List of hashes")
    Hashes --> ComputeMerkleRoot("Compute merkle root")
    ComputeMerkleRoot --> MerkleRoot["Merkle root"]
    MerkleRoot --> End@{ shape: framed-circle, label: "Stop" }
```

It needs to have functions to create and verify signatures with asymmetric cryptography. That means developers need to create a key pair. The private key is used to sign deployment records. The public key is used by users to verify the signatures.

I will generate the key pair with an mnemonic seed phrase. This way a user can store the seed phrase on a safe offline medium and recreate the key pair when needed.

I had first in mind to just store the data in an existing blockchain like Solana. Solana uses the Ed25519 algorithm for signing and verifying signatures and uses a Base58 encoding for the public key as the address. The public key is also the address of an account on Solana. This is much simpler than other blockchains do it but state of the art and safe. I decided to adapt this approach for the custom key pair as well. The public key is the address and the private key is used for signing. The public key is encoded in Base58 to get the address. Because Solana addresses are compatible to the custom address I will keep the the code. I will implement code to store the deployment record on Solana later.

I will store the keypair in DPAPI/Windows-Keychain to keep it secure. The user can generate a new key pair with the app and store it in the Windows-Keychain. The user can also select from stored key pairs in the Windows-Keychain and load the selected key pair for signing deployment records. The good news is. There is a lib for that. [jaraco/keyring](https://github.com/jaraco/keyring) Users can add a key pair for every blockchain to the Windows-Keychain and select the one they want to use for signing deployment records.

The app shows a main menu where key generation is menu item. 

```mermaid
---
title: "Creating a key pair"
---
flowchart TD
    Start@{ shape: sm-circ, label: "Small start" } --> MainMenu["Main menu"]
    MainMenu --> KeyPairManagement["Key pair management"]
    KeyPairManagement --> GenerateKeyPair["Generate new key pair with mnemonic seed phrase"]
    GenerateKeyPair --> EnterName["Enter name for key pair"]
    EnterName --> ShowMnemonic["Show mnemonic seed phrase"]
    ShowMnemonic --> Store{"store?"}
    Store -- Yes --> StoreInKeychain["Store key pair in Windows-Keychain/DPAPI"]
    Store -- No --> KeyPairManagement
    StoreInKeychain --> KeyPairManagement
    KeyPairManagement -- Cancel --> MainMenu
```

To create a deployment record the user can select "Create a deployment record" in the main menu. The creation process beginns. First the user has to select an existing key to sign the data and a folder containing the files to calculate the merkle root. After that, the app prompts the user to enter all needed information interactively.

The data is:

- Name of the software
- Version number
- Timestamp of deployment
- Commit hash
- Url to repository
- Author like name of company
- Contact information like email
- Merkle root of the deployed files

Validation is done during input to ensure, that all information is provided. After all data is entered, the deployment record is created and signed with the private key of the selected key pair. The deployment record is then sent to the service to be stored in the blockchain. Serialization is done with a binary format to save space. It must be done by the CLI because only the CLI knows the key pair. The service just receives the binary data and stores it in LevelDB. It also broadcasts the new deployment record to all other peers in the network. The signed deployment record will be the payload of a block. The header must be build by the service because it knows the previous block and can calculate the hash of the block. It also adds a timestamp, a block version, flags and a block height to the header.

```mermaid
architecture-beta
    group peer1[Peer 1]
    service client(server)[CLI] in peer1
    service server(server)[Service] in peer1
    service blockchain(database)[Blockchain] in peer1

    service peer2(internet)[Peer 2]
    service peer3(internet)[Peer 3]

    client:R -- L:server
    server:B -- T:blockchain
    server:R -- L:peer2
    server:R -- L:peer3
    peer2:B -- T:peer3
```

```mermaid
---
title: "Creating a deployment record"
---
sequenceDiagram
    autonumber
    actor User
    participant Client
    participant Server
    participant Blockchain@{ "type" : "database" }
    User ->> Client: Enters deployment data
    Client ->> Client: Calculate merkle root
    Client ->> Client: Create deployment record
    Client ->> Client: Hashes deployment record
    Client ->> Client: Sign hash of the record with private key
    Client ->> Server: Send deployment record
    Server ->> Server: Generates block header
    Server ->> Blockchain: Stores block
    Server ->> Network: Broadcasts new block to peers
```

I choosed the lib `mshpack` for the binary serialization of the deployment record because it is simple to use and has good performance. It fulfills all requirements I have for the serialization.

- It is deterministic. The same input always results in the same output. This is important for the signature verification and for the integrity of the data stored in the blockchain.
- It is compact. The binary format is smaller than a JSON or XML representation of the same data. This saves space in the blockchain and reduces the bandwidth needed for transmitting the data.
- It is widely used and supported.
- It supports complex data structures. The deployment record contains nested data like the metadata and the merkle root. `msgpack` can handle this complexity without any issues.
- It is fast. The serialization and deserialization processes are efficient and do not introduce significant overhead to the application.
- It can be deserialized.
- New fields can be added to the data structure without breaking compatibility with existing data. This is important for future extensions of the deployment record.

The data structure of the deployment record is as follows:

```mermaid
block
  columns 1
  version
  address
  merkle_root
  
  block:metadata
    author
    contact_info
    software_name
    version
    commit_hash
    repository_url
    timestamp
  end
```

This record is sha256 hashed and singed with the private key of the selected address.

The final structure of a block in the blockchains will contain a header and the signature as well. The header will be serialized with `struct` to have the full control and because there are only fixed sized fields.

This is how the header will look like:

```mermaid
---
title: "Block header structure"
---
packet
0-15: "Version"
+8: "Timestamp"
+4: "Flags"
+4: "Payload length"
+32: "Previous block hash"
```

- Version is the version of the block structure. This allows to make changes to the block structure in the future without breaking compatibility with existing blocks. The version is incremented when a change is made to the block structure.
- Timestamp is the time when the block was created. It is stored as a unix timestamp in seconds. This allows to sort the blocks by time and to check the age of a block.
- Flags can be used to store additional information about the block. For example, if it is a special block for some other purpose.
- Previous block hash is the hash of the previous block in the blockchain. This creates a chain of blocks and ensures the integrity of the blockchain. If a block is changed, the hash of the block changes and all following blocks become invalid.

A final block is composed of the three elements header, payload and signature.

```mermaid
block
  columns 1
  header
  payload
  signature
```

The address of the developer is known publicly. It is a Base58 encoded public key. Someone can use it to decode it into the public key. With that he can serialize the record again, calculate the hash and verify the signature. This ensures that the record was created by the owner of the private key and that the data has not been tampered with. It ensures the integrity and authenticity of the record. The hash of the block ensures that neither the header nor the payload of the block has been changed.

To spread a information in a P2P network all peers must know each other. The process of bootstrapping a new peer into the network is as follows. The new peer needs to know at least one existing peer in the network. This can be done by passing the address of an existing peer to the service. It has the form `host:port`. The new peer connects to the existing peer and sends a hello message. The existing peer adds the new peer to its list of known peers and sends its own list of known peers to the new peer. The new peer adds all received peers to its list of known peers. Both start to broadcast to all peers that a new node has entered the network. This way, the new peer becomes part of the network and can receive updates about new blocks from all other peers. 

```mermaid
sequenceDiagram
  actor NP as New Peer
  participant BP as Bootstrap Peer
  participant OP as Other Peers
  
  NP->>BP: hello {type: "hello", me: "new_peer:port", peers [...]}
  activate BP
  BP->>BP: Add New Peer to known peers
  BP->>NP: peer_list {peers [...]}
  deactivate BP
  activate NP
  NP->>NP: Add received peers to known list
  deactivate NP
  
  BP->>OP: hello {type: "hello", me: "bootstrap:port", peers: [new_peer, ...]}
  activate OP
  OP->>OP: Add New Peer to known peers
  OP->>BP: peer_list {peers: [...]}
  deactivate OP

  NP->>OP: hello {type: "hello", me: "new_peer:port", peers [...]}
```

The broadcasting of new peers has a lot of communication ways. The following diagram shows what happens when new peers enter the network.

```mermaid
sequenceDiagram
  autonumber
  participant 5000
  participant 5001
  participant 5002
  participant 5003

  rect rgb(21, 153, 175)
  5001->>5000: Hello 127.0.0.1:5000 üëã
  5000-->>5001: Hi 127.0.0.1:5001. Nice to meet you. üëã
  end

  rect rgb(19, 114, 158)
  5002->>5000: Hello 127.0.0.1:5000 üëã
  5000-->>5002: Hi 127.0.0.1:5002. Nice to meet you. üëã
  5000->>5001: Hello 127.0.0.1:5001 üëã
  5002->>5001: Hello 127.0.0.1:5001 üëã
  5001-->>5002: Hi 127.0.0.1:5002. Nice to meet you. üëã
  5001-->>5000: Hi 127.0.0.1:5000. Nice to meet you. üëã
  5001->>5002: Hello 127.0.0.1:5002 üëã
  5002-->>5001: Hi 127.0.0.1:5001. Nice to meet you. üëã
  end

  rect rgb(17, 75, 141)
  5003->>5000: Hello 127.0.0.1:5000 üëã
  5000-->>5003: Hi 127.0.0.1:5003. Nice to meet you. üëã
  5000->>5002: Hello 127.0.0.1:5002 üëã
  5003->>5001: Hello 127.0.0.1:5001 üëã
  5001-->>5003: Hi 127.0.0.1:5003. Nice to meet you. üëã
  5002-->>5000: Hi 127.0.0.1:5000. Nice to meet you. üëã
  5003->>5002: Hello 127.0.0.1:5002 üëã
  5002->>5003: Hello 127.0.0.1:5003 üëã
  5002-->>5003: Hi 127.0.0.1:5003. Nice to meet you. üëã
  5003-->>5002: Hi 127.0.0.1:5002. Nice to meet you. üëã
  end

  rect rgb(38, 26, 104)
  5004->>5001: Hello 127.0.0.1:5001 üëã
  5001-->>5004: Hi 127.0.0.1:5004. Nice to meet you. üëã
  5001->>5003: Hello 127.0.0.1:5003 üëã
  5004->>5003: Hello 127.0.0.1:5003 üëã
  5003-->>5001: Hi 127.0.0.1:5001. Nice to meet you. üëã
  5003->>5004: Hello 127.0.0.1:5004 üëã
  5003-->>5004: Hi 127.0.0.1:5004. Nice to meet you. üëã
  5004->>5000: Hello 127.0.0.1:5000 üëã
  5000-->>5004: Hi 127.0.0.1:5004. Nice to meet you. üëã
  5000->>5003: Hello 127.0.0.1:5003 üëã
  5004->>5002: Hello 127.0.0.1:5002 üëã
  5003-->>5000: Hi 127.0.0.1:5000. Nice to meet you. üëã
  5003->>5004: Hello 127.0.0.1:5004 üëã
  5002-->>5004: Hi 127.0.0.1:5004. Nice to meet you. üëã
  5004-->>5003: Hi 127.0.0.1:5003. Nice to meet you. üëã
  5004-->>5003: Hi 127.0.0.1:5003. Nice to meet you. üëã
  end
```

Because all peers have a handshake and share their peer lists everyone knows about each other. It does not matter which peer a new peer connects to. The new peer will be known by all other peers in the network after the handshake and the broadcasting of the peer list.

## :microscope: Dissection

| Integration test | 1.1                                                                                                                                                                                                       |
| ---------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Action           | I will generate the merkle root from a folder with files. Than I change something in a file and generate the merkle root again. As a third step I redo the change and generate the merkle root once more. |
| Expected result  | The merkle root is calculated the first time. After the file change the merkle root has changed. As a third step the merkle root is the same as the first time.                                           |


| Integration test | 1.2                                                                              |
| ---------------- | -------------------------------------------------------------------------------- |
| Action           | I will generate the merkle root from a folder with no files.                     |
| Expected result  | No merkle root is calculated. A message informs the user about the empty folder. |


| Integration test | 2.1                                                                                                                                                            |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Action           | First I will configure the mnemonic generation by defining the used language in `.env`. I will generate a key pair with a mnemonic seed phrase for Solana.     |
| Expected result  | The seed phrase is displayed to be written down. The key is stored in Windows-Keychain/DPAPI. I will send coins to the generated Solana address in the devnet. |


| Integration test | 2.2                                                                                                                                                            |
| ---------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Action           | First I will configure the mnemonic generation by defining the used language in `.env`. I will generate a custom key pair with a mnemonic seed phrase.         |
| Expected result  | The seed phrase is displayed to be written down. The key is stored in Windows-Keychain/DPAPI. I will send coins to the generated Solana address in the devnet. |


| Integration test | 2.3                                                                              |
| ---------------- | -------------------------------------------------------------------------------- |
| Action           | I will generate a new key pair and store the key pair in Windows-Keychain/DPAPI. |
| Expected result  | The key is stored and can be inspected with the Windows credential manager.      |


| Integration test | 2.4                                                                                                    |
| ---------------- | ------------------------------------------------------------------------------------------------------ |
| Action           | I will store one key pair per supported blockchain in Windows-Keychain/DPAPI and load them afterwards. |
| Expected result  | The app shows all keys stored on the system.                                                           |


| Integration test | 2.5                                                              |
| ---------------- | ---------------------------------------------------------------- |
| Action           | I will navigate to the key management menu and exit it via menu. |
| Expected result  | The user returns to the main menu.                               |


| Integration test | 2.6                                                                  |
| ---------------- | -------------------------------------------------------------------- |
| Action           | I will navigate to the key management menu and exit it via `CTRL+C`. |
| Expected result  | The user returns to the main menu.                                   |


| Integration test | 2.7                                                                                                  |
| ---------------- | ---------------------------------------------------------------------------------------------------- |
| Action           | I will navigate to "Generate a new address" and cancel it via `CTRL+C` before entering the key name. |
| Expected result  | The user returns to the key management menu.                                                         |


| Integration test | 3                                                                                                                                                                                                                                              |
| ---------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Action           | I will store a deployment record in a block on Solana.                                                                                                                                                                                         |
| Expected result  | I will be prompted to input the metadata. Validation ensures that all mandatory information is entered. The first step is to select a folder with data. The deployment is saved on blockchain and can be inspected with a blockchain explorer. |


| Integration test | 4.1                           |
| ---------------- | ----------------------------- |
| Action           | I will exit the app via menu. |
| Expected result  | The app exits gracefully.     |


| Integration test | 4.2                               |
| ---------------- | --------------------------------- |
| Action           | I will exit the app via `CTRL+C`. |
| Expected result  | The app exits gracefully.         |



## :hammer_and_wrench: Development

### :clipboard: TODOs

- [x] Compute merkle root from a set of files
- [x] Finish the diagram about merkle root calculation
- [x] Create a new `Keypair` for Solana
- [x] Add `.env` and add configuration `MNEMONIC_LANGUAGE` with default value `english`
- [x] Create a mnemonic seed phrase for key pair generation
- [x] Fix the tests
- [x] Make all addresses behave the same. The `CustomAddress` and the `SolanaAddress` should have the same interface. Maybe I can use inheritance to achieve this.
- [x] Create a key pair for signing and verifying signatures on Solana with mnemonic seed phrase
- [x] I don't need bip_utils
- [x] Write an own function to generate key pairs with Ed25519 which are compatible with Solana
- [x] Store the key pair in a secure way in Windows-Keychain/DPAPI in user scope
- [x] Load the key pair from Windows-Keychain/DPAPI
  - [x] Fix the `test_loads_the_keypair()` (Fix the syntax)
  - [x] # TODO: The loaded data should be stored in the properties of the instance.
  - [x] Implement the _from_keypair method to load the keypair from the keyring and set the private key, public key, and address properties accordingly for Solana addresses.
- [x] How can I use TPM/Windows Hello? (CNG keys)
- [x] How to create a additional passphrase and encrypt it with own KDF and store it in Windows-Keychain/DPAPI?
- [x] Load the key pair from Windows-Keychain/DPAPI
- [x] Move all code into a subfolger `cli`
- [x] Add `pytest.ini`, `conftest.py`, `*.code-workspace`, `helpers.py` and the new description in `README.md` in my template
- [x] Main Menu with key management as option
- [x] Exit the app via the main menu
- [x] Exit the app via Ctrl+C
- [x] Show menu with option to generate a key
- [x] Exit key manangement via menu
- [x] Exit key management via Ctrl+C
- [x] Menu item to generate a new key pair and store it in Windows-Keychain/DPAPI
- [x] Enter the name of the key
- [x] Fix tests
- [x] Prevent entering already existing names
- [x] Show the mnemonic seed phrase to the user and ask to write it down
- [x] Show the details in a nice way
- [x] Store the key pair in Windows-Keychain/DPAPI or go back to the key pair management menu
- [x] Create a deployment record
  - [x] Select a key to sign the deployment record
  - [x] Add tests
  - [x] Display the selected key nicely
  - [x] Select folder
  - [x] Calculate merkle root from folder with deployed files
  - [x] Input of metadata
    - [x] Timestamp defaults to now
  - [x] Validate the input data
  - [x] Load a keypair from Windows-Keychain/DPAPI
  - [x] Fix tests
  - [x] Create a deployment record from input data
  - [x] Sign the deployment record with the private key
  - [x] Add a version of the deployment record
  - [x] Document the serialization format of the deployment record
  - [x] Fix tests
  - [x] Hash the record and sign the hash with the private key, not the record itself. This is more efficient and the signature is smaller.
- [x] Services should not save themselfs as known peers
- [x] Service should spread known peers when receiving a hello message
- [x] Document the spreading of the peer list
- [x] Deployment records and store them in memory
- [x] Add 2 more peers from the service as Docker containers
- [x] Make the peers know each other
- [x] Send the deployment record from client to service
- [x] Serialize the deployment record into a binary format
- [ ] Create the header 
- [ ] Store the binaries into LevelDB
- [ ] Broadcast new deployments to all peers
- [ ] Check if the exception handling is well done
- [ ] Check if further tests must be written
- [ ] Are there license conflicts for new dependencies?
- [ ] Exisits a `global.json`
- [ ] Remove deactivated code
- [ ] Are all TODOs in the code done?
- [ ] Write meaningful comments
- [ ] Are there any compiler warnings?
- [ ] Do all unit tests pass in Visual Studio?
- [ ] Do all unit tests pass with `dotnet test`?
- [ ] `dotnet format Contracts.Service.sln --verify-no-changes --verbosity diagnostic`
- [ ] Is the version number correctly configured?
- [ ] Phrase a meaningful commit comment
- [ ] Check-in the changes and push them to the server
- [ ] Does the build on the buildserver succeed?
- [ ] Create a PR
- [ ] Task: Update `helpers.py` in Python project template
- [ ] Task: Update `copilot-instructions.md` in Python project template
- [ ] Task: Update `*.code-workspace` in Python project template

### :eyes: Review

- [ ] Initialize dev environment
- [ ] Checkout the version from Git
- [ ] Can the application be compiled?
- [ ] Are there any open warnings?
- [ ] Does the application work as a manually performed test?
- [ ] Is the layout and theme working in the UI?
- [ ] Is the UI translated?
- [ ] Is every input validated in frontend and backend?
- [ ] Are the requirements and acceptance criteria met?
- [ ] Is the code correct, clean, maintainable and well structured?
- [ ] Is the code well tested?
  - [ ] Does the test name describe the context and goal from a business perspective? What is being specified, not how it is technically implemented.
  - [ ] One aspect per test?
  - [ ] One essential assert per test. Asserts for the context should be marked as such.
  - [ ] Side-effect free and complete? No shared **instances** of objects. Especially the SUT.
  - [ ] Only fixed input data?
  - [ ] Only own code is tested?
  - [ ] Does each component have a test suite?
- [ ] Must something in README.md be updated or described?
- [ ] Does the pipeline work?
- [ ] Are there new database migrations before merging to `main`? This ensures that the database will be in the correct state after deployment.
- [ ] Shut down the dev environment

### :spiral_notepad: Notes

Notes about the development of the issue.

> [!NOTE]
> This is a note

> [!TIP]
> This is a tip.

> [!WARNING]
> This is a warning

> [!IMPORTANT]
> This info is important to know.

> [!CAUTION]
> This has possibly negative consequences.

## :mag: Debug

- [ ] ID: üü¢üî¥üü° Result: As Expected

## :books: Documentation
- [ ] Do I need a new PIA or update an existing one?
- [ ] Update the README.md
  - [ ] Add the Description of this document to the README.md
- [ ] Update the CHANGELOG.md
- [ ] Describe the setup of the story if needed for end users
- [ ] Does something in the wiki needed to be updated?
- [ ] Needs other stuff been documented?

### :bulb: Decisions

| Decision          | Cause                      |
| ----------------- | -------------------------- |
| What was decided? | Why was the decision made? |

### :page_facing_up: PIAs

Link to related PIA

### :link: Links

- [ebellocchia/bip\_utils: Generation of mnemonics, seeds, private/public keys and addresses for different types of cryptocurrencies](https://github.com/ebellocchia/bip_utils)
- [Solders ‚Äî solders 0.27.1 documentation](https://kevinheavey.github.io/solders/index.html)
- [sigstore/rekor: Software Supply Chain Transparency Log](https://github.com/sigstore/rekor)
- [jaraco/keyring](https://github.com/jaraco/keyring)
- [Questionary ‚Äî Questionary 2.0.1 documentation](https://questionary.readthedocs.io/en/stable/index.html)

## :clapper: Demo

- [ ] Setup a fresh demo environment
- [ ] Check all acceptance tests

## :package: Deployment

- [ ] Merge `feature` into `main` or `hotfix` into `production` and `main` and remove the `feature` branch
- [ ] Check if the compiled artifact is valid
- [ ] Cleanup the Git history locally on the dev system

## :beer: Retro

> [!TIP]  Was gab es zu lernen?
> What did I learn?

> [!WARNING] Where were the problems?
> Where did I have difficulties? What hindered my work?

## :unicorn: Magie

Hints and tricks that were helpful during the implementation or documentation.

<details>
    <summary>Emojis to label information</summary>

| Emoji                | Bedeutung                 |
| :------------------- | :------------------------ |
| :x:                  | Nein                      |
| :ok:                 | Ja                        |
| :warning:            | Achtung                   |
| :information_source: | Zus√§tzliche Informationen |
| :zzz:                | Wartet                    |
| :red_circle:         | Fehlschlag                |
| :green_circle:       | Erfolg                    |
| :yellow_circle:      | Problem                   |
| </details>           |                           |

<details> 
    <summary>PR</summary>

A PR needs a title that lets the reviewer recognize which ticket it belongs to. The format is:

`#<issue number> <issue title>`

It helps the reviewer if you provide details about the development environment. Breaking changes in services can make it unclear which versions of services the reviewer should use for the review.

The versions can be set up from artefacts or via Git by using the correct branches.

If the exact version is not critical, it may be sufficient to simply use the image with latest.

Here is a template for a PR:

```markdown
## Notes

BREAKING CHANGE: Is this a breaking change?

Is there anything special to note? Perhaps deviations from the ticket or details that came up during development?

## Changes

- Fixed a typo
- Optimized code
- New feature XYZ

## Development environment

### Versions

| Application | Version |
| :---------- | ------: |
| Client      |   1.5.0 |
| Service     |   1.2.4 |
| KeyCloak    |  latest |
| Postgres    |  latest |

### Setup

Scripts or test data used? Ideally attach or link it.
```
</details>

<details>
    <summary>Database migration with EF Core</summary>

```powershell
PS> cd .\src\ProjectName
PS> dotnet ef database update
PS> dotnet ef migrations add <migration_name> --project ..\ProjectName.csproj
```

`dotnet ef` can be updated with the command `dotnet tool update -g dotnet-ef --version 7.0.14`.

During development, sometimes it is necessary to recreate a migration:

```powershell
# List all migrations an copy the one to reset the database to.
dotnet ef migrations list

dotnet ef database update <migration_name> && dotnet ef migrations remove && dotnet ef migrations add <migration_name> --project ..\ProjectName.csproj && dotnet ef database update
```

> [!WARNING] ATTENTION
> Before merging into `main`, you must check if there are new migrations. The best way to do this is by comparing the migrations in `main` with those in your own branch. It is a good idea to commit migrations separately so that they can be easily reverted if necessary.

If there are new migrations on `main`, proceed as follows:

1. With the feature branch, reset the database to the last state before your own migration. `dotnet ef database update <migration_name>`
2. On the feature branch, remove the last commit with a `reset`.
3. Merge `main`.
4. Now create a new migration. `dotnet ef migrations add <migration_name> --project ..\ProjectName.csproj && dotnet ef database update`
5. Commit the migration.
</details>